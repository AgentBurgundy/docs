# Content Scripts

Content scripts run in the context of web pages.

> **NOTE:** Since Plasmo's default Typescript configuration treats all source files as modules, if you don't have any imports or exports in your code, you'll have to add an `export {}` line at the start of your file. (You will see this warning when creating your first content script!)

### Use cases:

- Scraping data from the current web page
- Selecting, finding, and styling elements from the current web page
- [Injecting UI elements into the current web page](#injecting-ui-elements)

## Adding a single content script

Create a `content.ts` file that exports an empty object and hack away! See [with-content-script](https://github.com/PlasmoHQ/examples/tree/main/with-content-script) for an example.

## Adding multiple content scripts

Create a `contents` directory for multiple content scripts, and add your content scripts there. See [with-many-content-scripts](https://github.com/PlasmoHQ/examples/tree/main/with-many-content-scripts) for an example.

## Customizing content script config

To provide a custom content script configuration, such as matching a custom domain per script, setting the `all_frames` key, etc., export a config object from your content script:

```ts
import type { PlasmoContentScript } from "plasmo"

export const config: PlasmoContentScript = {
  matches: ["<all_urls>"],
  all_frames: true
}
```

Working with this configuration object is a breeze thanks to the exported `PlasmoContentScript` type ðŸ¥³.

## Injecting UI elements

Plasmo has first-class support for mounting a React component into the current webpage via a content script.

1. Rename an existing content script or create a new one with the `tsx` extension
2. Export default a React component
3. Profit ðŸŽ‰

See [with-content-scripts-ui](https://github.com/PlasmoHQ/examples/tree/main/with-content-scripts-ui)

### How does Plasmo mount the React component?

Plasmo creates a [Shadow DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_shadow_DOM) and mounts the React component to it. This isolation technique prevents the web page's style from affecting the component's styling.

## getMountPoint

To mount/anchor a React component on top of a specific element on the current webpage, export a function called `getMountPoint` that returns a valid [`HTMLElement`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement):

```ts
export const getMountPoint = async () => document.querySelector("#element")
```

This function is asynchronous, which allows you to wait until the element exists. It is also agnostic. You can send the current webpage to a remote API via fetch to calculate the element selector, then query and return that element. The possibilities are endless!

Check [this file in with-content-scripts-ui](https://github.com/PlasmoHQ/examples/blob/main/with-content-scripts-ui/contents/plasmo-mount.tsx) for an example.

### How does getMountPoint anchor the React component?

`getMountPoint` first listens to the current window's scroll event. On each scroll event, it uses the `getBoundingClientRect` function to calculate the absolute position of the target element. Then, it applies the calculated position to the container used to mount your component.

## getStyle

To inject stylesheets into your content script UI's Shadow DOM or anywhere in the current webpage, export a `getStyle` function that returns a valid [`HTMLElement.style`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style) element:

```ts
import cssText from "data-text:~/contents/plasmo-overlay.css"

export const getStyle = () => {
  const style = document.createElement("style")
  style.textContent = cssText
  return style
}
```

Plasmo appends the style element into the Shadow DOM before the exported component's container.

See [the plasmo-overlay.tsx file in with-content-scripts-ui](https://github.com/PlasmoHQ/examples/blob/main/with-content-scripts-ui/contents/plasmo-overlay.tsx) for an example.

### Note about `data-text` schemes

In the example above, we use the `data-text` scheme to load our stylesheet as plain text into the `cssText` variable, which we then assign to our style element's `textContent`. Be cautious with this scheme's import path if you use the `src` directory, as noted [here](/workflows/faq#tilde-import-resolution).

## Styling the built-in shadow containers

Use the ids `#plasmo-mount-container` and `#plasmo-shadow-container` to tweak the style of these shadowDOM containers in your css:

```css
#plasmo-shadow-container {
  z-index: 99999;
}

#plasmo-mount-container {
  background: blue;
}
```

## getShadowHostId

There are cases when we might want to make run-time change to the shadow host. By exporting a `getShadowHostId` function (optionally async), we can assign the shadow host's DOM ID, which will allow us to select and modify it:

```ts
export const getShadowHostId = () => "custom-shadow-host"
```

## getRootContainer

To replace the Shadow DOM, export a `getRootContainer` function that returns a valid [`HTMLElement`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement).

Use cases:

- Extension needs to [absorb the styling of the host webpage](https://github.com/PlasmoHQ/plasmo/issues/10#issuecomment-1149499252)
- Extension needs to mount the component directly into the webpage instead of having an overlay shadow DOM

```ts
export const getRootContainer = () => {
  return document.querySelector("#feature")
}
```

> **NOTE:** If you export a `getRootContainer` function, Plasmo ignores the `getStyle` function since only the provided Shadow DOM container uses it. `getMountPoint`'s behavior might also be affected as the component's position will be relative to your provided container.

Check [this file in with-content-scripts-ui](https://github.com/PlasmoHQ/examples/blob/main/with-content-scripts-ui/contents/plasmo-root-container.tsx) for an example.

## Injecting into the main world

You must inject into the main world if you'd like to access the `window` object from your content script.

It's not currently possible to declaratively inject content scripts into the main world via the `content_scripts` manifest field.

Instead, Chrome offers a `chrome.scripting.executeScript` API that lets you inject content scripts into the main world.

```ts
 chrome.scripting.executeScript(
    {
      target: {
        tabId // the tab you want to inject into
      },
      world: "MAIN", // MAIN to access the window object
      func: windowChanger // function to inject
    },
    () => {
      console.log("Background script got callback after injection")
    }
  )
}
```

For the `func` key, you can pass in a Typescript function from your project, which will automatically convert to a JavaScript function when your extension bundles.

See [with-main-world-content-script-injection](https://github.com/PlasmoHQ/examples/tree/main/with-main-world-content-script-injection) for an example.

### Importing Web Accessible Resources

Use the `url:` scheme to load assets to be used from web-accessible resources.

Web-accessible resources are helpful if you'd like to reference static content from your content script, and the `data-base64` or `data-text` schemes aren't a good solution to your problem.

#### Usage

In your content script,

```ts
import myJavascriptFile from "url:./path/to/my/file/something.js"
```

`something.js` will be bundled and added to the `web_accessible_resources` manifest.json key automatically â€” no need to do it manually.

What is `myJavascriptFile`?

```sh
> console.log(myJavascriptFile)

chrome-extension://<your chrome ext id>/something.eb20bc99.js?1656000646313

```

The imported variable is a string that points to the path of the resource.

So access that JavaScript file however you'd like!

> NOTE: Please see this [note about `~` import resolution](/workflows/faq#tilde-import-resolution)
