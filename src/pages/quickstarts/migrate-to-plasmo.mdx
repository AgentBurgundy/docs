---
description: A guide on migrating to Plasmo from any browser extension setup.
---

# Migrate to Plasmo Framework

The Plasmo Browser Extension Framework is a powerful and declarative tool that simplifies the process of building browser extensions. It eliminates boilerplate code and provides a file-based configuration system that is easy to understand, use and [opt out of]().

In this guide, we will walk you through the process of transitioning from any extension project to Plasmo and highlight some of the key changes you will need to make.

## Install Plasmo CLI

Plasmo framework main driver is the Plasmo CLI. It is a NodeJS package that contains a compiler, a bundler, a development server, and a packager tailor made for browser extension:

```bash
pnpm install plasmo
```

To start the development server, run `plasmo dev`. To build the extension, run `plasmo build`. To package the extension, run `plasmo package`.

## manifest.json

Plasmo merges `manifest.json` into the `package.json` and abstracts away the most basic properties:

| Manifest Field              | Abstractions                                                           |
| :-------------------------- | :--------------------------------------------------------------------- |
| `icons`                     | Autogenerated with the `icon.png` in the `assets` directory            |
| `action`, `browser_actions` | [`popup.tsx`](#popup-options-newtab-pages)                             |
| `options_ui`                | [`options.tsx`](#popup-options-newtab-pages)                           |
| `content_scripts`           | [`contents/*.{ts,tsx}`, `content.ts`, `content.tsx`](#content-scripts) |
| `background`                | [`background.ts`](#background-service-worker)                          |
| `sandbox`                   | `sandbox.tsx`, [Sandbox Pages](/framework/sandbox-pages)               |
| `manifest_version`          | set by the `--target` build flag, default to `3`                       |
| `version`                   | set by the `version` field in `package.json`                           |
| `name`                      | set by the `displayName` field in `package.json`                       |
| `description`               | set by the `description` field in `package.json`                       |
| `author`                    | set by the `author` field in `package.json`                            |
| `homepage_url`              | set by the `homepage` field in `package.json`                          |

With Plasmo, common metadata between `package.json` and `manifest.json` are centralized, and any static file references (such as action, background, content scripts,...) are resolved automatically.

This enables you to focus on the metadata that matters such as name, description, OAuth, declarative_net_request, etc...

Furthermore, it enables the framework to provide even more powerful features such as:

- [Using environment variables in the manifest](/framework/env#in-manifest-overrides)
- [`node_modules` resolving for web-accessible resources](/framework/assets#assets-from-node_modules)
- [Targeting multiple browsers, manifest versions, and environments (dev, prod, staging, etc...)](/framework/workflows/build#with-a-specific-target)

## Popup, Options, Newtab Pages

One of the biggest boilerplate codes that will be removed as you transition to Plasmo is the need to manually mount your React/Svelte/Vue components.

Typically, in a manual extension project, these pages are created using an `index.html` template and associated JavaScript code:

```html filename="popup.html"
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Popup</title>
  </head>
  <body>
    <div id="root"></div>
    <script src="popup.js"></script>
  </body>
</html>
```

```js filename="popup.jsx"
import { createRoot } from "react"

import Popup from "./core/popup"

const root = document.getElementById("root")
createRoot(root).render(<PopupApp />)
```

Then, if you wanted to add TypeScript, LESS, SCSS, you would need to use webpack, Parcel or ESBuild, with extra plugins and loader setups to build the popup script and place it next to your `popup.html` file.

With Plasmo framework, you simply add a `popup.tsx` or `options.tsx` file in [the source code directory](/framework/customization/src), exporting default a React component. Plasmo will take care of the rest:

```ts filename="popup.tsx"
import Popup from "./core/popup"

import "./popup.scss"

export default Popup
```

As can be seen in the above example, using SCSS is as easy as importing them. Plasmo comes with built-in support for CSS, SCSS, LESS, CSS Modules, and PostCSS plugins.

This feature is available for the options page, newtab page, [sandbox pages](/framework/sandbox-pages) and any other [custom pages](#custom-pages) you may want to create.

## Custom Pages

In manual extension projects, creating custom pages typically requires additional HTML templates and associated JavaScript code:

```html filename="tabs/custom.html"
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Custom Page</title>
  </head>
  <body>
    <div id="root"></div>
    <script src="./custom.js"></script>
  </body>
</html>
```

```js filename="tabs/custom.js"
import { createRoot } from "react"

import CustomPage from "./core/custom-page"

const root = document.getElementById("root")
createRoot(CustomPage).render(<PopupApp />)
```

With Plasmo, you can use the built-in tab pages feature to easily create custom pages. Simply add a **`tabs`** folder in the [the source code directory](/framework/customization/src), and add your custom pages there, using `.tsx` files:

```ts filename="tabs/custom.tsx"
import Hello from "./core/hello"

export default Hello
```

The page will then be available at `chrome-extension://<extension-id>/tabs/custom.html`.

## Content Scripts

In manual extension projects, content scripts are typically specified in the `manifest.json` file and are written in JavaScript:

```json filename="manifest.json"
{
  "content_scripts": [
    {
      "matches": ["https://*/*", "http://*/*"],
      "js": ["content.js"],
      "css": ["content.css"],
      "run_at": "document_start"
    }
  ]
}
```

```js filename="content.js"
console.log("Hello from content script!")
```

With Plasmo, content scripts and their respective configs are specified directly within the script file:

```ts filename="content.ts"
import type { PlasmoContentScript } from "plasmo"

export const config: PlasmoContentScript = {
  matches: ["https://*/*", "http://*/*"],
  all_frames: true,
  css: ["~content.css"]
}

console.log("Hello from content script!")
```

No more moving back and forth between `manifest.json` and `content.js` files. Plasmo will automatically resolve the `content.ts` file and inject it into the final `manifest.json`.

An added benefit as demonstrated in the code above, is that the config is fully typed and thus can provide valuable auto-completion from your IDE - no more moving back and forth between the `manifest.json` and its documentation site!

To add multiple content scripts, simply create a directory named `contents`, and repeat the above steps.

```ts filename="contents/emerald-splash.ts"
document.body.style.backgroundColor = "green"
```

Since no config was exported from the above content script, the default config will be used:

```json
{
  "matches": ["<all_urls>"]
}
```

The abstraction above leads to an even more powerful feature. What if you can mount a React component directly onto a webpage via a content script by simply exporting a React component?

This is possible with Plasmo:

```tsx filename="contents/press-me.tsx"
export default function PressMeCSUI() {
  return <button>Press me</button>
}
```

This feature is called [Content Scripts UI](/framework/content-scripts-ui). To learn more about its API and how it works, check out the technical documentation on [its lifecycle](/framework/content-scripts-ui/life-cycle).

## Background Service Worker

In manual projects, creating a background service worker typically requires specifying the `background` property in the `manifest.json` file, and writing the service worker code in JavaScript:

```json filename="manifest.json"
{
  "background": {
    "service_worker": "background.js"
  }
}
```

```js filename="background.js"
console.log("Hello from BGSW!")
```

In Plasmo, the background service worker is specified by creating a `background.ts` file:

```ts filename="background.ts"
console.log("Hello from BGSW!")
```

You can import any modules that target standard service worker runtime into `background.ts`, and it will work as expected. For example the `bip39` module:

```ts filename="background.ts"
import { generateMnemonic } from "bip39"

console.log(
  "Live now; make now always the most precious time. Now will never come again."
)
console.log(generateMnemonic())
```

## Environment Variables

In manual projects, managing environment variables typically requires additional configuration and setup.

With Plasmo, [environment variables are supported out of the box](/framework/env).

## Opting Out

Plasmo abstraction philosophy is to remove the most common configuration and boilerplate code. This enables developers to work under a higher layer of abstraction - their chosen UI library/framework such as React, Vue, Svelte. We believe this is the path to create more powerful and beautiful extensions.

Thus, opting out of Plasmo is as easy as removing the `plasmo` dependency from your `package.json` file, and taking your component out onto your custom setups. This is possible because all glue codes generated by Plasmo are injected at the framework compiler and bundler layer, making your feature code extremely portable.

You can also use Plasmo as much or as little as needed. All chrome APIs are available, and you can use them directly in your feature code. For example, instead of using the [messaging API](/framework/messaging), you can use the `chrome.runtime.messaging` API directly. The same goes for content script and extension pages.
