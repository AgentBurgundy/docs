# Development cycle

Once your project is setup, you can start developing your extension by first `cd` inside your project, then:

```sh
pnpm dev
# OR
npm run dev
# OR
yarn dev
# OR
plasmo dev
```

This will create a dev bundle for your extension, as well as a hot-reloading development server, which will automatically update your extension bundle on file changes. It will also reload your browser on content-script changes.

To create a production bundle for distribution, run:

```sh
pnpm build
# OR
npm run build
# OR
yarn build
# OR
plasmo build
```

You can optionally supplies a `--zip` flag to the build command to create a zip bundle ready to be uploaded to the web stores:

```sh
pnpm build --zip
# OR
npm run build --zip
# OR
yarn build --zip
# OR
plasmo build --zip
```

> **NOTE:** Since plasmo's default typescript configuration treats all source file as a module, if your source is not importing anything, please add a `export {}` at the start of your source. (You will see this warning when you created your first content script!)

## Adding a Popup Page

Create a `popup.tsx` file or a `popup/index.tsx` file that export default a React component -> your popup is ready ðŸš€! See [with-popup](https://github.com/PlasmoHQ/examples/tree/main/with-content-script).

## Adding Content Scripts

Create a `content.ts` file that export an empty object (or import some library), and hack away! See [with-content-script](https://github.com/PlasmoHQ/examples/tree/main/with-content-script).

For multiple content scripts, create a `contents` directory, and add your content scripts there. See [with-many-content-scripts](https://github.com/PlasmoHQ/examples/tree/main/with-many-content-scripts).

To provide custom content script configuration (such as matching custom domain per script, all_frames, etc...), exports a config object from your content script like so:

```ts
import type { PlasmoContentScript } from "plasmo"

export const config: PlasmoContentScript = {
  matches: ["<all_urls>"],
  all_frames: true
}
```

Working with this configuration object is a breeze thanks to the exported `PlasmoContentScript` type ðŸ¥³.

## Adding a Background script

In the root directory, create a `background.ts` file, and you are set to start hacking ðŸ’ª. See [with-background](https://github.com/PlasmoHQ/examples/tree/main/with-background).

## Adding Options UI

Simply create either an `options.tsx` or `options/index.tsx` file to render the options_ui ðŸ‘Œ. See [with-options](https://github.com/PlasmoHQ/examples/tree/main/with-options-ui)

## Adding Environment Variables

The Plasmo framework utilize a similar env file cascading/overiding strategy to NextJS, using [`dotenv` package](https://www.npmjs.com/package/dotenv). To add environment variables, create an `.env.local` file like so:

```
SHIP_NAME=ncc-1701
SHIELD_FREQUENCY=42
```

You can then use it in any of your source file as follow:

```tsx
// For TSX (popups, options):
const FrontHull = () => <h1>{process.env.SHIP_NAME}</h1>

// For TS (content scripts or background-scripts):
const shield = new Shield(process.env.SHIELD_FREQUENCY)
```

To overide variable on production build with `plasmo build`, supply a `.env.production` file, re-declaring just the variable you need to overide.

You might also enjoy Typescript intelisense with your environment variables ðŸ¤“. To do so, create an `index.d.ts` file with a declaration like below and you are good to go:

```ts
declare namespace NodeJS {
  interface ProcessEnv {
    SHIP_NAME?: string
    SHIELD_FREQUENCY?: number
  }
}
```

See [with-env-files](https://github.com/PlasmoHQ/examples/tree/main/with-env-files) for more details.

## Submit Your Extension

The Plasmo framework ships with a convenient github action called [Browser Platform Publish](http://bpp.browser.market/) or BPP for short. This action will automatically publish your extension to all supported browser extension market. It is configured to be run upon manual trigger, but can be altered to run automatically if needed.

To start publishing your Plasmo extension, setup a `keys.json` file with the schema:

```json
{
  "$schema": "https://raw.githubusercontent.com/PlasmoHQ/bpp/v2/keys.schema.json"
}
```

This schema is most useful if your editor supports `json schema`. Make sure you only declare valid submissinon credential, otherwise the action will report failure.

> NOTE: this file is ignored thanks to our friendly neighborhood `.gitignore`

To learn more about the tokens required to submit, please see this [token guide](https://github.com/PlasmoHQ/bms/blob/main/tokens.md). The final key might look like this:

```json
{
  "$schema": "https://raw.githubusercontent.com/plasmo-corp/bpp/v2/keys.schema.json",
  "chrome": {
    "clientId": "123",
    "refreshToken": "789",
    "extId": "abcd"
  },
  "edge": {
    "clientId": "aaaaaaa-aaaa-bbbb-cccc-dddddddddddd",
    "clientSecret": "abcdefg",
    "productId": "aaaaaaa-aaaa-bbbb-cccc-dddddddddddd",
    "accessTokenUrl": "https://login.microsoftonline.com/aaaaaaa-aaaa-bbbb-cccc-dddddddddddd/oauth2/v2.0/token"
  }
}
```

Copy this key, and create a [repository secret on github](https://docs.github.com/en/actions/security-guides/encrypted-secrets#creating-encrypted-secrets-for-a-repository) with the name `SUBMIT_KEYS`, and the value be the content of the key you just copied.
Then, go on github and trigger the action manually when you need to submit a new extension version!
